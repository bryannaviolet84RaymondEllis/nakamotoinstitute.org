[
    {
        "thread_id": 130,
        "name": "Hepatizon",
        "poster_url": "https://bitcointalk.org/index.php?action=profile;u=506",
        "subject": "Reading/Writing Blocks and FLATDATA",
        "url": "https://bitcointalk.org/index.php?topic=555.msg5423#msg5423",
        "date": "July 24, 2010, 01:27:32 AM",
        "content": "<div class=\"post\">I'm trying to understand the way Bitcoin stores block data - among other things I want to run some statistics on the block chain / transaction history and check just how anonymous Bitcoin really is. \u00a0So I went to the source to see how Bitcoin reads/writes block data to file.<br/><br/>(ETA: this is in 0.3.2)<br/><br/>In main.h we have:<br/><br/><div class=\"codeheader\">Code: (CBlock::WriteToDisk)</div><div class=\"code\">bool WriteToDisk(bool fWriteTransactions, unsigned int&amp; nFileRet, unsigned int&amp; nBlockPosRet)<br/>{<br/>\u00a0\u00a0 \u00a0// Open history file to append<br/>\u00a0\u00a0 \u00a0CAutoFile fileout = AppendBlockFile(nFileRet);<br/>\u00a0\u00a0 \u00a0if (!fileout)<br/>\u00a0\u00a0 \u00a0 \u00a0 \u00a0return error(\"CBlock::WriteToDisk() : AppendBlockFile failed\");<br/>\u00a0\u00a0 \u00a0if (!fWriteTransactions)<br/>\u00a0\u00a0 \u00a0 \u00a0 \u00a0fileout.nType |= SER_BLOCKHEADERONLY;<br/><br/>\u00a0\u00a0 \u00a0// Write index header<br/>\u00a0\u00a0 \u00a0unsigned int nSize = fileout.GetSerializeSize(*this);<br/>\u00a0\u00a0 \u00a0fileout &lt;&lt; FLATDATA(pchMessageStart) &lt;&lt; nSize;<br/><br/>\u00a0\u00a0 \u00a0// Write block<br/>\u00a0\u00a0 \u00a0nBlockPosRet = ftell(fileout);<br/>\u00a0\u00a0 \u00a0if (nBlockPosRet == -1)<br/>\u00a0\u00a0 \u00a0 \u00a0 \u00a0return error(\"CBlock::WriteToDisk() : ftell failed\");<br/>\u00a0\u00a0 \u00a0fileout &lt;&lt; *this;<br/><br/>\u00a0\u00a0 \u00a0// Flush stdio buffers and commit to disk before returning<br/>\u00a0\u00a0 \u00a0fflush(fileout);<br/>#ifdef __WXMSW__<br/>\u00a0\u00a0 \u00a0_commit(_fileno(fileout));<br/>#else<br/>\u00a0\u00a0 \u00a0fsync(fileno(fileout));<br/>#endif<br/><br/>\u00a0\u00a0 \u00a0return true;<br/>}<br/></div><br/>and <br/><br/><div class=\"codeheader\">Code: (CBlock::ReadFromDisk)</div><div class=\"code\">bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions=true)<br/>{<br/>\u00a0\u00a0 \u00a0SetNull();<br/><br/>\u00a0\u00a0 \u00a0// Open history file to read<br/>\u00a0\u00a0 \u00a0CAutoFile filein = OpenBlockFile(nFile, nBlockPos, \"rb\");<br/>\u00a0\u00a0 \u00a0if (!filein)<br/>\u00a0\u00a0 \u00a0 \u00a0 \u00a0return error(\"CBlock::ReadFromDisk() : OpenBlockFile failed\");<br/>\u00a0\u00a0 \u00a0if (!fReadTransactions)<br/>\u00a0\u00a0 \u00a0 \u00a0 \u00a0filein.nType |= SER_BLOCKHEADERONLY;<br/><br/>\u00a0\u00a0 \u00a0// Read block<br/>\u00a0\u00a0 \u00a0filein &gt;&gt; *this;<br/><br/>\u00a0\u00a0 \u00a0// Check the header<br/>\u00a0\u00a0 \u00a0if (CBigNum().SetCompact(nBits) &gt; bnProofOfWorkLimit)<br/>\u00a0\u00a0 \u00a0 \u00a0 \u00a0return error(\"CBlock::ReadFromDisk() : nBits errors in block header\");<br/>\u00a0\u00a0 \u00a0if (GetHash() &gt; CBigNum().SetCompact(nBits).getuint256())<br/>\u00a0\u00a0 \u00a0 \u00a0 \u00a0return error(\"CBlock::ReadFromDisk() : GetHash() errors in block header\");<br/><br/>\u00a0\u00a0 \u00a0return true;<br/>}<br/></div><br/>FLATDATA is defined in serialize.h like so:<br/><div class=\"codeheader\">Code: (FLATDATA)</div><div class=\"code\">//<br/>// Wrapper for serializing arrays and POD<br/>// There's a clever template way to make arrays serialize normally, but MSVC6 doesn't support it<br/>//<br/>#define FLATDATA(obj) \u00a0 REF(CFlatData((char*)&amp;(obj), (char*)&amp;(obj) + sizeof(obj)))<br/>class CFlatData<br/>{<br/>protected:<br/>\u00a0\u00a0 \u00a0char* pbegin;<br/>\u00a0\u00a0 \u00a0char* pend;<br/>public:<br/>\u00a0\u00a0 \u00a0CFlatData(void* pbeginIn, void* pendIn) : pbegin((char*)pbeginIn), pend((char*)pendIn) { }<br/>\u00a0\u00a0 \u00a0char* begin() { return pbegin; }<br/>\u00a0\u00a0 \u00a0const char* begin() const { return pbegin; }<br/>\u00a0\u00a0 \u00a0char* end() { return pend; }<br/>\u00a0\u00a0 \u00a0const char* end() const { return pend; }<br/><br/>\u00a0\u00a0 \u00a0unsigned int GetSerializeSize(int, int=0) const<br/>\u00a0\u00a0 \u00a0{<br/>\u00a0\u00a0 \u00a0 \u00a0 \u00a0return pend - pbegin;<br/>\u00a0\u00a0 \u00a0}<br/><br/>\u00a0\u00a0 \u00a0template&lt;typename Stream&gt;<br/>\u00a0\u00a0 \u00a0void Serialize(Stream&amp; s, int, int=0) const<br/>\u00a0\u00a0 \u00a0{<br/>\u00a0\u00a0 \u00a0 \u00a0 \u00a0s.write(pbegin, pend - pbegin);<br/>\u00a0\u00a0 \u00a0}<br/><br/>\u00a0\u00a0 \u00a0template&lt;typename Stream&gt;<br/>\u00a0\u00a0 \u00a0void Unserialize(Stream&amp; s, int, int=0)<br/>\u00a0\u00a0 \u00a0{<br/>\u00a0\u00a0 \u00a0 \u00a0 \u00a0s.read(pbegin, pend - pbegin);<br/>\u00a0\u00a0 \u00a0}<br/>};<br/></div><br/>Now - and I apologize if I'm reading this wrong, this is a little more advanced C/C++ code than I'm used to - as I understand it, the FLATDATA call interprets the raw bytes of a CBlock object as an array (stream??) of characters. \u00a0The CBlock::WriteToDisk method writes the constant 4-byte message header (0xf9, 0xbe, 0xb4, 0xd9), the size of the CBlock object in bytes, and then the FLATDATA of the CBlock it's writing to disk - which is just the raw bytes of the CBlock object. \u00a0So after the header, the data written to file is byte-for-byte the same as the CBlock object represented in memory. \u00a0Also, if I'm reading it correctly, CBlock::ReadFromFile copies those bytes directly into the space allocated for a CBlock object in memory to re-create the block. \u00a0Is this correct?<br/><br/>Related question - I am under the impression that the exact way an instance of a C++ class is represented internally not guaranteed under standards; compiling a program with different compilers or different optimization flags can change the order in which member variables are stored in memory, and some debug mode compilers even add a few bytes between member variables to make memory inspection easier. \u00a0I'm not positive about this, it's just something I've picked up and never seriously questioned.</div>",
        "post_num": 1,
        "is_displayed": true,
        "nested_level": 0
    },
    {
        "thread_id": 130,
        "name": "Gavin Andresen",
        "poster_url": "https://bitcointalk.org/index.php?action=profile;u=224",
        "subject": "Re: Reading/Writing Blocks and FLATDATA",
        "url": "https://bitcointalk.org/index.php?topic=555.msg5424#msg5424",
        "date": "July 24, 2010, 01:44:02 AM",
        "content": "<div class=\"post\">They key bits of code are:<br/><div class=\"codeheader\">Code:</div><div class=\"code\">fileout &lt;&lt; FLATDATA(pchMessageStart) &lt;&lt; nSize;<br/>...<br/>fileout &lt;&lt; *this;</div>pchMessageStart are the four magic bytes, and those are written with FLATDATA.<br/><br/>The CBlock itself is written by &lt;&lt; *this, and that's done by the IMPLEMENT_SERIALIZE in main.h:<br/><div class=\"codeheader\">Code:</div><div class=\"code\">\u00a0 \u00a0 IMPLEMENT_SERIALIZE<br/>\u00a0 \u00a0 (<br/>\u00a0 \u00a0 \u00a0 \u00a0 READWRITE(this-&gt;nVersion);<br/>\u00a0 \u00a0 \u00a0 \u00a0 nVersion = this-&gt;nVersion;<br/>\u00a0 \u00a0 \u00a0 \u00a0 READWRITE(hashPrevBlock);<br/>\u00a0 \u00a0 \u00a0 \u00a0 READWRITE(hashMerkleRoot);<br/>\u00a0 \u00a0 \u00a0 \u00a0 READWRITE(nTime);<br/>\u00a0 \u00a0 \u00a0 \u00a0 READWRITE(nBits);<br/>\u00a0 \u00a0 \u00a0 \u00a0 READWRITE(nNonce);<br/><br/>\u00a0 \u00a0 \u00a0 \u00a0 // ConnectBlock depends on vtx being last so it can calculate offset\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0<br/>\u00a0 \u00a0 \u00a0 \u00a0 if (!(nType &amp; (SER_GETHASH|SER_BLOCKHEADERONLY)))<br/>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 READWRITE(vtx);<br/>\u00a0 \u00a0 \u00a0 \u00a0 else if (fRead)<br/>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 const_cast&lt;CBlock*&gt;(this)-&gt;vtx.clear();<br/>\u00a0 \u00a0 )<br/></div><br/>The READWRITE macros Do The Right Thing, reading in or writing out the members in a machine-independent way.<br/><br/>See <a href=\"http://github.com/gavinandresen/bitcointools\">http://github.com/gavinandresen/bitcointools</a> for simplified Python code that can dump out transactions and blocks.<br/><br/></div>",
        "post_num": 2,
        "is_displayed": true,
        "nested_level": 0
    },
    {
        "thread_id": 130,
        "name": "Hepatizon",
        "poster_url": "https://bitcointalk.org/index.php?action=profile;u=506",
        "subject": "Re: Reading/Writing Blocks and FLATDATA",
        "url": "https://bitcointalk.org/index.php?topic=555.msg5435#msg5435",
        "date": "July 24, 2010, 02:53:05 AM",
        "content": "<div class=\"post\">Thanks for clearing that up for me.<br/><br/>I keep making really elementary code mistakes....</div>",
        "post_num": 3,
        "is_displayed": true,
        "nested_level": 0
    },
    {
        "thread_id": 130,
        "name": "satoshi",
        "poster_url": "https://bitcointalk.org/index.php?action=profile;u=3",
        "subject": "Re: Reading/Writing Blocks and FLATDATA",
        "url": "https://bitcointalk.org/index.php?topic=555.msg5450#msg5450",
        "date": "July 24, 2010, 04:04:20 AM",
        "content": "<div class=\"post\">FLATDATA was a workaround to serialize a fixed field length array.\u00a0 There was a cleaner way to make it understand how to serialize arrays directly, but MSVC6 couldn't do it and I wanted to keep compatibility with MSVC6 at that time.\u00a0 We don't support MSVC6 anymore because we use something in Boost that doesn't.\u00a0 We lost support for it after 0.2.0.\u00a0 Maybe someday I'll swap in the clean way that just knows how to serialize fixed length arrays without wrapping them in FLATDATA.</div>",
        "post_num": 4,
        "is_displayed": true,
        "nested_level": 0
    }
]